<p align="center"><b>МОНУ НТУУ КПІ ім. Ігоря Сікорського ФПМ СПіСКС</b></p>
<p align="center">
<b>Звіт з лабораторної роботи 3</b><br/>
"Конструктивний і деструктивний підходи до роботи зі списками"<br/>
дисципліни "Вступ до функціонального програмування"
</p>

<p align="right"> 
<b>Студент</b>: 
<em> Лабазов Володимир КВ-11</em></p>

<p align="right"><b>Рік</b>: <em>2025</em></p>

## Загальне завдання
Реалізуйте алгоритм сортування чисел у списку двома способами: функціонально і
імперативно.
1. Функціональний варіант реалізації має базуватись на використанні рекурсії і
конструюванні нових списків щоразу, коли необхідно виконати зміну вхідного списку.
Не допускається використання: псевдо-функцій, деструктивних операцій, циклів,
функцій вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Також реалізована функція не має
бути функціоналом (тобто приймати на вхід функції в якості аргументів).
2. Імперативний варіант реалізації має базуватись на використанні циклів і
деструктивних функцій (псевдофункцій). Не допускається використання функцій
вищого порядку або функцій для роботи зі списками/послідовностями, що
використовуються як функції вищого порядку. Тим не менш, оригінальний список
цей варіант реалізації також не має змінювати, тому перед виконанням
деструктивних змін варто застосувати функцію copy-list (в разі необхідності).
Також реалізована функція не має бути функціоналом (тобто приймати на вхід
функції в якості аргументів).

Алгоритм, який необхідно реалізувати, задається варіантом (п. 3.1.1). Зміст і шаблон звіту
наведені в п. 3.2.

Кожна реалізована функція має бути протестована для різних тестових наборів. Тести
мають бути оформленні у вигляді модульних тестів (наприклад, як наведено у п. 2.3).

## Варіант 4

Алгоритм сортування вставкою №2 (з лінійним пошуком справа) за незменшенням.

## Лістинг функції з використанням конструктивного підходу

```lisp
(defun insertion-sort-func (lst)
	(labels (
		(insert (x sorted)
			(cond 
				((null sorted) (list x))
				((<= x (car sorted)) (cons x sorted))
				(t (cons (car sorted) (insert x (cdr sorted))))
			)
		)
		)
		(if (null lst)
			nil
			(insert (car lst) (insertion-sort-func (cdr lst)))
		)
	)
)
```

## Лістинг функції з використанням деструктивного підходу

```lisp
(defun insertion-sort-imp (lst)
	(let ((copy (copy-list lst)))
		(loop for i from 1 below (length copy)
			do (let ((current (nth i copy)) (j i))
					(loop while (and (> j 0) (> (nth (- j 1) copy) current))
						do (progn
							(setf (nth j copy) (nth (- j 1) copy))
							(decf j))
					)
				   (setf (nth j copy) current)
				)
		)
		copy
	)
)
```

## Тестові набори та утиліти

```lisp
(defun test-insertion-sort (ins-sort-function)
  (assert (equal (funcall ins-sort-function '()) '())) ;empty
  (assert (equal (funcall ins-sort-function '(1)) '(1))) ;one element
  (assert (equal (funcall ins-sort-function '(1 2 3 4 5)) '(1 2 3 4 5))) ;sorted
  (assert (equal (funcall ins-sort-function '(5 4 3 2 1)) '(1 2 3 4 5))) ;reversed
  (assert (equal (funcall ins-sort-function '(3 1 4 1 5 9)) '(1 1 3 4 5 9))) ;random
  (assert (equal (funcall ins-sort-function '(10 9 8 8 7 7 6 6 5)) '(5 6 6 7 7 8 8 9 10))) ;duplicates
)
```

## Тестування

```lisp
CL-USER> (test-insertion-sort #'insertion-sort-func)
NIL
```

